#include "iostream"
#include "vector"

using namespace std;

// 格雷码，即循环码，相邻的两个之间只有一位不同(本题重点)
// 如：0 -> 0000; 1 -> 0001; 2 -> 0011
// 也可看作，若一个i位的二进制数，其格雷码为：
// 第i位不变，后面的第k位（k<n）位 k位和k+1位的异或
// 如：二进制:1000 <- 8 -> 格雷码: 1100

// 我们再来看题，
//
//给你一个整数 n，你需要重复执行多次下述操作将其转换为 0 ：
// 1. 翻转 n 的二进制表示中最右侧位（第 0 位）。
// 2. 如果第 (i-1) 位为 1 且从第 (i-2) 位到第 0 位都为 0，则翻转 n 的二进制表示中的第 i 位。
// 返回将 n 转换为 0 的最小操作次数。

// 为什么说格雷码转换成二进制码就是答案?
// 我们前10的格雷码
// -----------------------------------------------------------------------------------------------------------------------------------
//    十进制数    ：  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |  13  |  14  |  15  |
//- ---------------------------------------------------------------------------------------------------------------------------------
//四位自然二进制码： 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
//-----------------------------------------------------------------------------------------------------------------------------------
//  四位典型格雷码： 0000 | 0001 | 0011 | 0010 | 0110 | 0111 | 0101 | 0100 | 1100 | 1101 | 1111 | 1110 | 1010 | 1011 | 1001 | 1000 |
//-----------------------------------------------------------------------------------------------------------------------------------
// 我们从后往前看，不就是题目的要求？
// 比如：5 -> 格雷码：0111 -> 转换为 格雷码 0000 的次数也为5
class Solution {
public:
    int minimumOneBitOperations(int n) {
        int ans = 0;
        while (n) {
            // 因为格雷码转二进制：
            // B(n)=G(n)^0=G(n)
            // B(n-1)=B(n)^G(n-1)=G(n)^G(n-1)
            // ...
            // 所以：B(k)=G(n)^G(n-1)...^G(k)
            // 即：B = G^(G>>1)^(G>>2)^...^(G>>(n-2))^(G>>(n-1))
            ans ^= n;
            n >>= 1; // 实现上面的公式
        }
        return ans;

    }
};

